# 操作系统

### 1. 锁

* **互斥锁**：占有资源互斥其他进程同时拥有该资源
* **读写锁**：读锁、写锁、
* **自旋锁**：没资源时进行忙等待

### 2. 进程间通信

* **管道**：
  - 速度慢，容量有限，只有父子进程能通讯    
  
  - 管道有两端一端负责输入，一端负责输出，所以两端就分别连接两个进程。进程1负责将数据输入到缓冲区，进程2将缓冲区的数据拿出来，这样就实现了两个进程的通信。
* **FIFO(有名管道)**（[ref](https://www.cnblogs.com/MrListening/p/5858358.html)）：
  - 任何进程间都能通讯，但速度慢   
  
  - FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存储于文件系统中。
  
  - 命名管道是一个设备文件，因此，即使进程与创建FIFO的进程不存在亲缘关系，只要可以访问该路径，就能够通过FIFO相互通信。
* **消息队列**：（[ref](https://blog.csdn.net/blade2001/article/details/5193464)）
  - 容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    
  
  - 消息队列提供了一种由一个进程向另一个进程发送块数据的方法。另外，每一个数据块被看作有一个类型，而接收进程可以独立接收具有不同类型的数据块。
  
  - 通过消息发送到内存或基于磁盘的队列或从它读出而提供信息交换。
* **信号量**：([ref](https://blog.csdn.net/gatieme/article/details/50994533))
  - 不能传递复杂消息，只能用来同步    
* **共享内存区**：
  - 能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全
  
  - 共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存
* **socket**

### 3. 进程与线程

- **进程**
  
  - 就是一个正在执行程序的实例
  
  - 包括程序计数器、寄存器、变量的当前值

- **线程**
  
  - 类似一个程序中的一个任务，进程中的实际运作单位
  
  - 同一个进程的所有线程共享一样的地址空间
  
  - 轻量

- **用户空间和内核管理的线程**
  
  - 取决于线程包存在于哪里
  
  - 内核管理需要操作系统支持
  
  - 用户空间需要每个进程维护一张线程表

- **线程与进程的区别**
  
  - 进程之间相互独立（资源的独立），而某一进程的各线程间共享资源（如果不能共享，岂不就与进程没多大区别了）；
  
  - 由于进程的独立性，当进程间要相互通信时，系统只能提供各种外部方法，比较繁琐，而线程间的通信可以通过共享数据来实现；
  
  - 线程的状态切换比进程更快捷且开销更小；
  
  - 在多线程系统中，线程才是可执行对象，因为线程是进程中的并发任务的一种抽象。原先，进程是运行任务的主体，有了线程之后，运行任务的重担就落到了线程身上。

### 4. 虚拟内存

- 它将主存看成是一个存储在磁盘空间上的地址空间的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。

- 它为内阁进程提供了一致的地址空间,简化了内存管理。

- 它保护了每个进程的地址空间不被其他进程破坏。

### 5. 页面置换算法

- **NRU** —— 对LRU粗糙近似

- **FIFO** —— 先进先出

- **LRU** —— 最近最少使用，计数，值最小的拜拜，用链表实现

### 6. 死锁

- ##### 定义
  
  - 指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。
  
  - 多线程环境中，我们经常会遇到多个线程访问同一个共享资源的情况，只有拿到锁的线程才可以访问共享资源，通过锁就可以让线程对共享资源的访问都是顺序的，避免出现一些数据不一致的问题。

- ##### 产生原因
  
  - 互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。
  
  - 请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。
  
  - 非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。
  
  - 循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。

- ##### 死锁避免
  
  - 死锁避免算法动态地检测资源分配状态以确保循环等待条件不成立。
  
  - **银行家算法**
    
    - 当一个进程申请使用资源的时候，银行家算法通过先 **试探** 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。
    - **安全状态**即为当前的资源能否满足进程队列中的某一进程

- ##### 死锁预防
  
  - 允许进程同时访问某些资源 -- 互斥  
  - 允许进程强行从占有者那里夺取某些资源 -- 非剥夺条件  
  - 进程在运行前一次性地向系统申请它所需要的全部资源 -- 请求与保持  
  - 把资源事先分类编号，按号分配，杜绝环路 -- 循环等待

- ##### 从死锁中恢复
  
  - **抢占资源**
    
    我们可以从资源所有者(进程)中获取其中一个资源，并将其交给另一个进程，并期望它能够完成执行，并且会尽快释放该资源。
  
  - **回滚到安全状态**
    
    系统通过各种状态进入死锁状态。 操作系统将系统回滚到以前的安全状态。 为此，操作系统需要在每个状态下执行检查指针。
  
  - **杀死一个进程**
    
    杀死一个迄今为止工作量最少的
  
  - **杀死所有进程**

### 7. 活锁

- 活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。

- 活锁和[死锁](https://baike.baidu.com/item/%E6%AD%BB%E9%94%81)的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；

- 活锁有可能自行解开，死锁则不能。

- 活锁是拿到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。

### 8. 任务调度

- 先来先去服务

- 时间片轮转法

- 多级反馈队列算法

- 最短进程优先

- 最短剩余时间优先

- 最高响应比优先

- 多级反馈队列调度算法
  
  - 多级反馈队列算法，不必事先知道各种进程所需要执行的时间，他是当前被公认的一种较好的进程调度算法。其实施过程如下：
  
  - 设置多个就绪队列，并为各个队列赋予不同的优先级。在优先权越高的队列中，为每个进程所规定的执行时间片就越小。
  
  - 当一个新进程进入内存后，首先放入第一队列的末尾，按照先来先去原则排队等候调度。如果他能在一个时间片中完成，便可撤离；如果未完成，就转入第二队列的末尾，同样等待调度.....如此下去，当一个长作业（进程）从第一队列依次将到第n队列（最后队列）后，便按第n队列时间片轮转运行。
  
  - 仅当第一队列空闲的时候，调度程序才调度第二队列中的进程运行；仅当第1到（i-1）队列空时，才会调度第i队列中的进程运行，并执行相应的时间片轮转。
  
  - 如果处理机正在处理第i队列中某进程，又有新进程进入优先权较高的队列，则此新队列抢占正在运行的处理机，并把正在运行的进程放在第i队列的队尾。
