# 1、智能指针模板
	auto_ptr和shared_ptr 只能用于new
	unique_ptr能用于new 和 new[]
	
	auto_ptr不安全
	unique_ptr只有一个指针拥有内存块的拥有权，把其赋值给unique_ptr会报错
	shared_ptr使用计数，有一个指向就加一，直到计数为零时才调用delete
	
# 2、C++中提供了四种类型转换符：static_cast、dynamic_cast、const_cast、reinterpret_cast
	 * static_cast可以完全替代c的类型转换，而且在对对象指针之间的类型转换时，可以将父类指针转换成子类指针，也可以将子类指针转换成父类指针，但是如果两个类不相关则无法相互转换。 需注意的是，如果父类指针指向一个父类对象，此时将父类指针转换成子类指针虽然可以通过static_cast实现，但是这种转换很不安全；如果父类指针本身就指向子类指针则不存在安全问题。
	const_cast转换过程中增加或删除const属性。
	reinterpret_cast: （interpret是解释的意思，reinterpret即为重新解释，此标识符的意思即为数据的二进制形式重新解释，但是不改变其值。）有着和C风格的强制转换同样的能力。它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用。
	dynamic_cast 只能用于对象指针之间的类型转换，可以将父类指针转换成子类指针，也可以将子类指针转换成父类指针，转换结果也可以是引用，但是dynamic_cast不等同于static_cast。dynamic_cast在将父类指针转换为子类指针的过程中，需要对其背后的对象类型进行检查，以保证类型完全匹配，而static_cast不会。只有当一个父类指针指向一个子类对象，且父类中包含虚函数时，使用dynamic_cast将父类指针转换成子类指针才会成功，否则返回空指针，如果是引用则抛出异常。
	1. 其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。
	2. 不能用于内置的基本数据类型的强制转换。
	3. dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。
	4. 使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。
	

