# 数据结构

---

## 二叉树

- 使用指针实现
1. #### 满二叉树
   - 每一个非叶节点都有两个子节点
   
   - 叶节点数**等于**其分支节点数加**一**
   
   - 空子树的的数量**等于**其节点数加一
   
   - 哈夫曼编码树是满二叉树

2. #### 完全二叉树
   - 堆数据结构是完全二叉树
   
   - ##### 使用数组实现完全二叉树
     
     - Parent(r) = (r - 1) / 2 ---向下取整
     
     - LeftChild = 2r + 1
     
     - RightChild = 2r + 2

3. #### 遍历
   - 前序遍历，中左右，根节点在序列第一位
   
   - 中序遍历，左中右，
   
   - 后序遍历，左右中，根节点在序列最后一位
   
   ```
   void preorder(BinNode* root)
   {
       if(root == NULL)return;
       visit(root);
       preorder(root -> left);
       preorder(root -> right);
   }
   
   void preorder2(BinNode* root)
   {
       visit(root);
       if(root -> left) preorder(root -> left);
       if(root -> right) preorder(root -> right);
   }
   ```
   
   - preorder比preorder2要好
     
     * 虽然2比1少调用函数一半的次数，但2要访问左右子树两次
     
     * 安全性，2无法判断根节点一开始就为空的情况

# 

4. #### 二叉搜索树
   
   - 该结点的值都小于或***等于***的右子树中任意一个结点的值
   
   - 删除一个值后，可使用右子树的最小值填补
     
     - 若使用左子树的最大值替换，可能会出现左子树的值与替换值相等的情况，破坏二叉搜索树的性质
     
     

5. #### 堆
   
   - 完全二叉树
   
   - 使用**数组**实现（~~再被问到怎么取堆的最后一个值，还不会答~~）
   
   - 插入一个值的时间代价：log(n)，最远调整距离为树的高度
   
   -  siftdown：从倒数第二层进行siftdown，直到到达根节点（每一个结点需要递归向下判断结点值是否大于子节点的值，来确定是否需要siftdown）
   
   

6. #### Haffman编码树
   
   - 取最小权值的两个进行建子树
   
   - Huffman编码的最简形式在文件压缩技术中并不常用
   
   - 逆过程根据每一位的值是“0”或“1”确定选择左分支还是右分支——直到到达一个叶结点



## 树

森林定义为一棵或更多棵树的集合

1. #### 表示方法
   
   - 一：提供最左结点和右兄弟结点的指针，也可以使用改进的节点表，第一列为左兄弟节点索引，第二列为值，第三列为父索引值，第四列为右兄弟结点索引值
   
   - 二：提供父结点指针，通常用于判断两个结点是否在同一棵树中（看根结点是否相同），难以寻找结点的兄弟结点
   
   - 三：子结点表，表中第一列为结点的值，第二列为父结点的索引值，接下来为保存有子结点索引值的链表
   
   - 四：动态表示法
   
   

2. 只有空指针NULL才被当做叶结点，止痒的节点表提供足够的信息来恢复树结构。



## 内排序

1. #### 
