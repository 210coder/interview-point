# 文章总结

---

### 1. 字符串匹配

- #### Sunday算法
  
  **Sunday 算法**  与  [**KMP 算法**](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247485939&idx=1&sn=b25f39b5644da92c4047bbbd9936f73c&chksm=fa0e6672cd79ef64dda0a21e23c2817edf4a64cbb75b9bed328d6519c6cd4fef36d03a4cb309&scene=21#wechat_redirect)  一样是从前往后匹配，在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。
  - 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1；
  
  - 否则，其移动位数 = 模式串长度 - 该字符***最右***出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。



- #### KMP算法（主要求next数组）
  - 先求所有从0开始的子串的前缀和后缀匹配的最大长度
  
  - next数组相当于将最大长度数组向右移动一位，并在第一位置为-1
  
  - ![Image\KMP](Image\KMP.png)
  
  - ```
    void GetNext(char* p,int next[])
    {
    	int pLen = strlen(p);
    	next[0] = -1;
    	int k = -1;
    	int j = 0;
    	while (j < pLen - 1)
    	{
    		//p[k]表示前缀，p[j]表示后缀
    		if (k == -1 || p[j] == p[k]) 
    		{
    			++k;
    			++j;
    			next[j] = k;
    		}
    		else 
    		{
    			k = next[k];
    		}
    	}
    }
    ```

![nextArray](Image/nextArray.png)



### 2. Knuth洗牌算法

- 直接先上代码

```
for(int i=n-1; i>=0; i--)
    swap(arr[i], arr[rand() % (i+1)])
```

- 相当于将第i位的元素随机与前i位（包括自己）元素交换位置

- 某元素在第i位的概率为1/i

- 在i-1位的概率为`((i-1)/i) *(1/(i-1))=1/i`

- 容易得出所有元素的在某一位置都是相等的



### 3.
