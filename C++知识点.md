### 1、智能指针模板

* auto_ptr和shared_ptr 只能用于new

* unique_ptr能用于new 和 new[]

* auto_ptr不安全

* unique_ptr只有一个指针拥有内存块的拥有权，把其赋值给unique_ptr会报错

* shared_ptr使用计数，有一个指向就加一，直到计数为零时才调用delete

#### 

### 2、C++中提供了四种类型转换符：static_cast、dynamic_cast、const_cast、reinterpret_cast

* static_cast可以完全替代c的类型转换，而且在对对象指针之间的类型转换时，可以将父类指针转换成子类指针，也可以将子类指针转换成父类指针，但是如果两个类不相关则无法相互转换。 需注意的是，如果父类指针指向一个父类对象，此时将父类指针转换成子类指针虽然可以通过static_cast实现，但是这种转换很不安全；如果父类指针本身就指向子类指针则不存在安全问题。
* const_cast转换过程中增加或删除const属性。
* reinterpret_cast: （interpret是解释的意思，reinterpret即为重新解释，此标识符的意思即为数据的二进制形式重新解释，但是不改变其值。）有着和C风格的强制转换同样的能力。它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用。
* dynamic_cast 只能用于对象指针之间的类型转换，可以将父类指针转换成子类指针，也可以将子类指针转换成父类指针，转换结果也可以是引用，但是dynamic_cast不等同于static_cast。dynamic_cast在将父类指针转换为子类指针的过程中，需要对其背后的对象类型进行检查，以保证类型完全匹配，而static_cast不会。只有当一个父类指针指向一个子类对象，且父类中包含虚函数时，使用dynamic_cast将父类指针转换成子类指针才会成功，否则返回空指针，如果是引用则抛出异常。
  1. 其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。
  2. 不能用于内置的基本数据类型的强制转换。
  3. dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。
  4. 使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。

#### 

### 3、malloc和new区别

* __属性__：new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。
* __参数__：使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。
* __返回类型__：new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void \* ，需要通过强制类型转换将void\*指针转换成我们需要的类型。
* __分配失败__：new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
* __自定义类型__：new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
* __重载__：C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。
* __内存区域__：new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。  

#### 

### 4、static关键字总结（作用域、生命周期）

* 修饰函数内局部变量
  
    __变量生命周期和程序一致，多次调用仅会初始化一次，存储在静态存储区__

* 修饰全局变量或函数
  
    __限制全局变量或函数的作用域在本文件__

* 修饰成员变量或成员函数
  
    __多个实例共用一个变量，无需实例化便可以使用静态变量或静态函数__

#### 

### 5、extern关键字总结（全局变量和函数可以使得它们能够跨文件被访问）

* 函数的extern修饰无意义，因为函数本身就是extern
* 局部变量的声明不能有extern的修饰，且局部变量在运行时才在堆栈部分分配内存
* 全局变量在外部使用声明时，extern关键字是必须的，如果变量没有extern修饰且没有显式的初始化，同样成为变量的定义，因此此时必须加extern，而编译器在此标记存储空间在执行时加载内并初始化为0
* extern C 表示使用C来编译连接

#### 

### 6、const关键字总结（作用域限制在本编译模块）

* 修饰变量 
  
    __不能修改内容__

* 修饰函数返回值
  
    __函数返回值只能赋值给对应的const变量__

* 修饰成员函数（int fun() const{}）不允许修饰类非成员函数
  
    __禁止修改成员变量__

#### const可以和extern一起使用，可以作用于外部模块，而static不能与extern一起使用

#### 

### 7、explicit关键字总结

* 防止类构造函数的隐式转换

* 当构造函数只有一个参数，或其他非第一个参数有默认值时支持隐式转换
  
  ```cpp
  class A {
  public:
    //这里用explicit关键词来修饰类构造函数.
    explicit A(int i = 5)
    {
        m_a = i;
    }
  private:
    int m_a;
  };
  ```
  
  ```cpp
  {
      A s;
      //这样直接赋值,会被提示错误,因为explicit抑制隐式转换的进行
      s = 10;//这样会报错!!!如果没有explicit修饰不会报错
      //当然显示转换还是可以的.
      s = A(20);
  
      system("pause");
      return 0;
  }
  ```

#### 

### 8、typeof 和 define 的区别（```typedef int（*funName）（）```）

* __原理__：define不做类型检查，只做替换，是预处理指令；typedef做类型检查，能在一个函数定义里面使用typedef
* __功能__：define可以定义类型别名，常量、变量、编译开关等；typedef一般只定义类型别名
* __作用域__：define本文件；typedef函数外则到文件结尾，函数内则到函数结束
* __指针操作__：

```cpp
#define INTPTR1 int*
typedef int* INTPTR2;
INTPTR1 p1, p2;    //一个指针，一个整型
INTPTR2 p3, p4;    //两个整型
```

```cpp
#define INTPTR1 int*
typedef int* INTPTR2;
int a = 1;
int b = 2;
int c = 3;
const INTPTR1 p1 = &a;    //常量指针
const INTPTR2 p2 = &b;    //指针常量
INTPTR2 const p3 = &c;    //指针常量
```

#### 

### 9
