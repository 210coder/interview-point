# Computer Network

# (Advanced)

###### by XiaoMing

---

## TCP

#### 1. 三次握手

- TCP服务器进程先创建传输控制块TCB, **服务器就进入了 LISTEN（监听）状态**

- TCP客户端进程也是先创建传输控制块TCB, 然后向服务器发出连接请求报文，此时报文首部中的同步标志位SYN=1, 同时选择一个**初始序列号 seq = x**, 此时，TCP**客户端进程进入了 SYN-SENT（同步已发送状态）状态**。
  
  > TCP规定, SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。

- **TCP服务器收到请求报文后, 如果同意连接, 则发出确认报文**。确认报文中的 ACK=1, SYN=1, 确认序号是 x+1, 同时也要为自己初始化一个序列号 seq = y, 此时, **TCP服务器进程进入了SYN-RCVD（同步收到）状态**。
  
  > 这个报文也不能携带数据, 但是同样要消耗一个序号。

- TCP客户端进程收到确认后还, 要向服务器给出确认。确认报文的ACK=1，确认序号是 y+1，自己的序列号是 x+1. 

- 此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。

- ##### 为什么不用两次
  
  - 主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。
    
    - 如果第一次ACK因网络拥塞无法到达客户端，客户端会再次发送连接请求
    
    - 然后第二次成功了，传输完数据关闭连接，此时如果服务端接收到第一次的连接请求，建立连接，造成资源浪费
    
    - 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。
  
  - 两次的话可能会造成死锁
    
    - 当C发送请求给S，S返回ACK，但ACK丢失；此时C在等待，S以为连接建立成功
    
    - C在不断等待ACK，并忽略S发来的数据
    
    - S因无法收到数据的ACK而一直重发数据

- ##### 为什么不用四次
  
  - 四次多余，该出现的情况还是会出现

#### 

#### 2. 四次挥手

- 客户端传输完数据后，发出连接释放报文

- 服务端收到后返回ACK

- 服务端传输完数据后，发出连接释放报文

- 客户端收到后返回ACK，**注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。**

- 服务端收到ACK，断开连接

- ##### 为什么最后客户端还要等待 2*MSL的时间呢?
  
  - 保证客户端发送的最后一个ACK报文能够到达服务器
  
  - 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中

- ##### 为什么建立连接是三次握手，关闭连接确是四次挥手呢？
  
  - 保证数据传输完成

#### 3. 确认应答机制(ACK机制)

- TCP将每个字节的数据都进行了编号, 即为序列号.

- 每一个ACK都带有对应的确认序列号, 意思是告诉发送者, 我已经收到了哪些数据; 下一次你要从哪里开始发.

#### 

#### 4. 超时重传机制

- 主机A发送数据给B之后, 可能因为网络拥堵等原因, 数据无法到达主机B 。如果主机A在一个特定时间间隔内没有收到B发来的确认应答, 就会进行重发

- TCP为了保证任何环境下都能保持较高性能的通信, 因此会动态计算这个最大超时时间.
  
  - 超时以500ms为一个单位进行控制, 每次判定超时重发的超时时间都是500ms的整数倍. 
  
  - 如果重发一次之后, 仍然得不到应答, 等待 `2*500ms` 后再进行重传.  依次类推, 以指数形式递增. 
  
  - 累计到一定的重传次数, TCP认为网络异常或者对端主机出现异常, 强制关闭连接.

#### 

#### 5. 滑动窗口

- 发送前四个段的时候, 不需要等待任何ACK, 直接发送。

- 收到第一个ACK确认应答后, 窗口向后移动, 继续发送第五六七八段的数据

- 因为这个窗口不断向后滑动, 所以叫做**滑动窗口.**
  
  ![\Image\SlidingWindow](..\Image\SlidingWindow.png)

- ##### 丢包重传
  
  - 数据包已经收到, 但确认应答ACK丢了.
    
    - 这种情况下, 部分ACK丢失并无大碍, 因为还可以通过后续的ACK来确认对方已经收到了哪些数据包.
  
  - 数据包丢失
    
    - 触发**快重传**
    
    - 接收端会在收到重复的ACK序号（丢失的数据序号）

#### 

#### 6. 流量控制

- **流量控制(Flow Control)**：TCP支持根据接收端的处理能力, 来决定发送端的发送速度

- 接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 “窗口大小” 字段,  通过ACK通知发送端

- 当接收端缓冲区满了, 就会将窗口置为0;  这时发送方不再发送数据, 但是需要***定期发送一个窗口探测数据段, 让接收端把窗口大小再告诉发送端***

#### 

#### 7. 拥塞控制

- 慢启动，拥塞窗口指数增长，直至大于阈值

- 拥塞避免，线性增长

- 收到三个冗余ACK：
  
  - 协议栈会做如下工作：
    
    - 拥塞窗口减半**cwnd=cwnd/2**
    
    - **ssthresh=cwnd（减半后的值）**
  
  - 然后启动快速恢复算法：
    
    - 设置cwnd = ssthresh＋ack个数（一般情况下会是3个Dup Acks），然后**重传指定的数据包**；
    
    - 如果再次收到Dup Acks，则cwnd=cwnd+1，  并且在条件允许的情况下发送下一个报文段（非重传报文段）  
    
    - 如果收到新的ACK, 则快速恢复算法结束，设置cwnd = ssthresh， 进入拥塞避免阶段
  
  - ##### TCP New Reno算法
    
    - 为了避免3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时
    
    - **如果只有这一个包丢了，那么，重传这个包后回来的ack会把整个已经被发送方传输出去的数据的ack返回来**。
    
    - 如果没有的话，说明有多个包丢了。我们叫这个ACK为**Partial ACK。**  
    
    - 一旦发送方这边发现了Partial ACK出现（即多个包丢失）于是继续重传滑动窗口里未被ack的第一个包。直到再也收不到了Partial Ack，才真正结束快速恢复这个过程。

#### 

#### 8. 延迟应答

- 如果接收数据的主机立刻返回ACK应答, 这时候返回的窗口可能比较小.
  
  > 假设接收端缓冲区为1M. 一次收到了500K的数据;
  > 
  > 如果立刻应答, 返回的窗口大小就是500K; 
  > 
  > 但实际上可能处理端处理的速度很快, 10ms之内就把500K数据从缓冲区消费掉了; 在这种情况下, 接收端处理还远没有达到自己的极限, 即使窗口再放大一些, 也能处理过来; 如果接收端稍微等一会儿再应答, 比如等待200ms再应答, 那么这个时候返回的窗口大小就是1M

- ###### 延迟应答限制
  
  - 数量限制: 每隔N个包就应答一次
  
  - 时间限制: 超过最大延迟时间就应答一次

#### 

#### 捎带应答

- ACK可以搭数据报的顺风车一同传送

#### 

#### TCP异常情况

- 进程终止: 进程终止会释放文件描述符, 仍然可以发送FIN. 和正常关闭没有什么区别.

- 机器重启: 和进程终止的情况相同.

- 机器掉电/网线断开: 接收端认为连接还在, 一旦接收端有写入操作, 接收端发现连接已经不在了, 就会进行  `reset`. 即使没有写入操作, TCP自己也内置了一个保活定时器, 会定期询问对方是否还在. 如果对方不在, 也会把连接释放.

- 另外, 应用层的某些协议, 也有一些这样的检测机制.  
  
  > 例如HTTP长连接中, 也会定期检测对方的状态.
  > 
  > 例如QQ, 在QQ断线之后, 也会定期尝试重新连接.
