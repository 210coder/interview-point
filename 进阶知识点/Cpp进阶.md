# C plus plus

1. ### 内存泄漏
   
   - **定义**
     
     - 在编写应用程序的时候，程序分配了一块内存，但已经不再持有引用这块内存的对象（通常是指针）
     
     - 虽然这些内存被分配出去，但是无法收回，将无法被其他的进程所使用
     
     - 被泄漏的内存将在整个程序声明周期内都不可使用
   
   ###### 
   
   - **原因**
     
     - 是在使用new或malloc动态分配堆上的内存空间，而并未使用delete或free及时释放掉内存。
   
   ###### 
   
   - **危害**
     
     - 虽然这些内存被分配出去，但是无法收回，将无法被其他的进程所使用
     
     - 被泄漏的内存将在整个程序声明周期内都不可使用
       
       ###### 
   
   - **情况**
     
     - **类所有动态分配的成员变量**，一定记得在析构函数中全部进行判断释放内存。
     
     - **指针容器** ,使用`std::vector<CType*>`时，记得在clear或是删除一个元素之前，应该释放指针指向的内容。
     
     - **资源泄漏**,有些类型对象如CDialog，CWindow，CFile，CImage等需要在Delete前做Close、Release、Destroy等操作的，Delete时检查是否已经调用了相应的扫尾函数。 这个要具体情况具体分析了，比如CDialog的子类销毁时往往需要先调用OnDestroy或是DestroyWindow，不然就可能会存在资源泄漏的问题。
     
     - **异常分支**，若正常分支有内存需要释放，则不要忘了异常分支的内存释放如try语句的catch分支，函数中的多个return分支都要考虑到相应内存的释放。
     
     - **不为虚的析构函数**，因为编译器会认为你删除的是一个基类类型的指针，当然就不会去调用子类的成员变量的析构函数的了
     
     - **线程的安全退出**，防止线程不安全退出导致内存泄漏，线程进行安全退出，防止非正常退出的内存泄漏问题。
     
     - **delete void * 的指针**，导致没有调用到对象的析构函数，析构的所有清理工作都没有去执行从而导致内存的泄露；
   
   #### 

2. ### 内存越界（内存溢出）

3. ### 编译过程
