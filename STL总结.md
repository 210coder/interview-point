# STL

- 对于关联式容器，应该使用其所提供的`find()`函数，而不是STL算法提供的`find()`函数，因为`STL`算法的`find()`函数只是循序遍历寻找。



1. ### vector
   
   - ##### 实现
     
     - 顺序表
     
     - 内存连续，超过最大容量要移位
   
   - ##### 增
     
     - 超过最大容量要重新分配内存
     
     - 最大容量分配一般以1.5至2倍增加
   
   - ##### 删
     
     - daicha 
   
   - ##### 优缺点
     
     - 地址连续，查找、遍历方便
     
     - 增删操作效率低
     
     - 对内存的连续性要求高
   
   #### 

2. ### list
   
   - ##### 实现
     
     - 双向链表，有prev，next指针
   
   - ##### 增、插
     
     - 尾部插入常量时间
     
     - 使用`find()`函数获取插入点位置需要线性时间
   
   - ##### 删
     
     - 删除元素常量时间
     
     - 删除中间的元素，`end`迭代器不会失效
     
     - `end`迭代器使用尾部元素指向的空节点
   
   - ##### 优缺点
     
     - 插入删除常量时间
     
     - 但是获取元素索引需要线性时间
   
   - **双向链表**在插入和删除操作更好，单向链表删除需要获取前一个元素，而双向的话获取当前元素就好。

#### 

3. ### deque
   - ##### 实现
     
     - deque没有`capacity`的概念，它是动态地以分段连续空间组合而成
     
     - deque采用一块`map`(一小块连续空间，其中每个元素都是指针)，指向另一段连续线性空间（缓冲区，用来储存数据）
   
   - #### 增删查
     
     - **增**，中间也需要内存移动，后端增可能需要增加缓冲区，单不需要vector那样整体移动
     
     - **删**，跟vector差不多，但过程中可能多了用map计算各个缓冲区的地址
     
     - **查**，也提供随机访问，但是需要读取map计算地址，效率较vector要差
   
   - ##### 优缺点
     
     - 相对于vector在头部的操作效率较差，deque可以高效率在头尾双端操作
     
     - deque的迭代器不是普通指针，其复杂度和vector比差远了，对deque进行`sort()`排序，为了的高效率可以将deque复制到vector，再排序。
     
     - 每个缓冲区大小是一样的，假如大小为8，申请20个元素，则第三个缓冲区会有4个备用空间，用来以后使用

#### 

4. ### stack
   - 默认使用`deque`作为底层实现，`list`也行
   
   - 不提供迭代器，不允许遍历
   
   - 使用`push()`进栈，`pop()`出栈
   
   - **先入后出**

#### 

5. ### queue
   - 默认使用`deque`作为底层实现，`list`也行
   
   - 不提供迭代器，不允许遍历
   
   - 使用`push()`进队，`pop()`出队
   
   - **先入先出**

#### 

6. ### set
   - ##### 实现
     
     - 使用`RB-tree`作为底层
     
     - 所有元素都会根据键值自动被排序
   
   - ##### 优缺点
     
     - 不可以通过迭代器修改元素的值
     
     - set插入调用的是`RB-tree`的`insert_unique()`，因为**键值必须唯一**
     
     - 插入或删除元素，当前的迭代器不会失效
   
   ##### 
7. ### map
   - ##### 实现
     
     - 使用`RB-tree`作为底层
     
     - 所有元素都会根据键值自动被排序
     
     - 所有元素都是pair，同时拥有键值（key）和实值（value）
   
   - ##### 插入与下标
     
     - `insert()`函数返回一个pair<iterator,bool>`,bool`值表示是否插入成功，成功的话`iterator`指向插入的元素
     
     - 可以使用`[]`操作符与键值获取实值，该操作可以做左值和右值，因为该实值是以引用的方式传递
   
   - ##### 优缺点
     
     - 不可以通过迭代器修改元素的键值，但可以修改实值
     
     - set插入调用的是`RB-tree`的`insert_unique()`，因为**键值必须唯一**
     
     - 插入或删除元素，当前的迭代器不会失效

#### 

8. ### multiset & multimap
   
   - 与`set`或`map`基本一致，只是可以存在相同的键值
   
   - 插入时调用`RB-tree`的`insert_equal()`

#### 

9. ### hashtable（非公开，底层结构）
   
   - 使用`vector`作为底层实现，储存`node*`节点
   
   - 冲突解决方法使用开链，即只用对应链表储存冲突元素
   
   - `hash function` 只能处理`char，int，long，const char*`，其他需要自定义`hash function`

#### 

10. #### hash_set & hash_map
    
    - 使用hashtable作为底层实现
    
    - 因为使用hashtable所以不提供自动排序功能
    
    - 不允许键值的重复

#### 

11. ### hash_multiset & hash_multimap
    
    - 基本一致
    
    - 可以重复键值
